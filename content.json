{"pages":[{"title":"关于“随手记”","text":"学过用过的东西以前没有记下来的习惯，总觉得手边常用的不需要记，不常用的有个印象用时再查资料就是。 最近两年在创业公司尝试了若干不同的细分方向，很多知识点都处于时而要用，又都不那么常用的状态，就发现没有个记录的话，有些东西隔段时间再用到，只是记得个大概却找不到细节出处的时候很浪费时间。就打算要做些记录，但一直忙东忙西，并没有真的记下什么来(其实主要是懒)。 最近工作相对稳定，决心开始记点东西，要是写在自己的笔记里怕又犯了懒癌，还是找个相对公开的地方比较合适。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"Android Studio 3.6.X 不能直接运行老项目的问题","text":"今天升级了Android Studio到 3.6.2，结果项目不能直接run到手机里了，报错如下 ApkProvisionException: No outputs for the main artifact of variant: debug 降级 AS 或 升级 Gradle 成本都颇高 可以通过修改 Installation Options 临时解决具体修改是 Deploy 设置为 Nothing 并增加一个 Before lanuch 的 gradle task参考下图： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/15/Android-Studio-3-6-X-%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E8%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Electron项目yarn安装依赖","text":"yarn 淘宝镜像 1234yarn config set registry https://registry.npm.taobao.orgyarn config get registryhttps://registry.npm.taobao.org Electron 淘宝镜像 1export ELECTRON_MIRROR=\"https://cdn.npm.taobao.org/dist/electron/\" 官方文档传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/28/Electron%E9%A1%B9%E7%9B%AEyarn%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96/"},{"title":"GitHub Actions 搞定Hexo自动部署","text":"第一次尝试 GitHub Actions，很赞👍 语法简单，上手容易，但又足够强大，感觉可以干任何事情 复用性强，很容易通过use复用，市场里有很多常用action 配额给的足够 官方文档传送门 [当前仓库部署用的workflow] 123456789101112131415161718192021222324252627282930313233343536373839name: Deployon: [push] # 触发事件jobs: build: runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu name: A job to deploy blog. steps: - name: Checkout # 获取源码 uses: actions/checkout@v1 # 使用官方常用action with: # 条件 submodules: true - name: copyCfg # 更新配置 run: cp _config.theme.yml themes/icarus/_config.yml # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - name: Install Dependencies if: steps.cache.outputs.cache-hit != 'true' # 如果没有cache run: npm install # 安装 node modules 相关依赖 # 发布 - name: Deploy id: deploy uses: sma11black/hexo-action@v1.0.0 # 使用 社区贡献的action with: deploy_key: ${{ secrets.DEPLOY_KEY }} user_name: xuewuli user_email: 26448247@qq.com document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/17/GitHub-Actions-%E6%90%9E%E5%AE%9AHexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"title":"Netty的ByteBuf与Protostuff序列化实现零拷贝","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/22/Netty%E7%9A%84ByteBuf%E4%B8%8EProtostuff%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"title":"Cache friendly code","text":"什么是缓存友好代码？学院派的回答大概会涉及CPU多级缓存结构等原理性的内容，但也许只要理解“缓存是CPU里一块比内存小很多，但也快很多的存储空间，访问内存时CPU会一段一段的把内存读取到缓存，如果后续操作的数据在缓存里就不会读内存，整体速度就快了”，这样的基本概念其实就可以开始编写缓存友好的代码了。 多核多线程时还会有False Sharing等问题，可以入门后再逐步了解。 下面是一段演示代码。对一个二维数组的数据求和，区别只是按“行”访问还是按“列”访问(会影响cache是否命中)，品出其中差别也就算入门了。 在数据集小到可以全部放在cache中的时候，是真的飞起了，当然现实中很少有这样理想的情况，缓存友好的核心也就是如何设计能高命中的数据结构和代码。 常见的做法会把对象属性以线性存储，并分独立函数更新。这里会有点和面向对象拧着的感觉，需要适应一下，对外接口OOP内部组织DOP。 Unity的DOTS中的ECS(Entity Component System )是不错的概念参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;template &lt;int M, int N&gt;int sumarrayrows(int a[M][N]){ int sum = 0; for (int i = 0; i != M; ++i) for (int j = 0; j != N; ++j) sum += a[i][j]; return sum;}template &lt;int M, int N&gt;int sumarraycols(int a[M][N]){ int sum = 0; for (int j = 0; j != N; ++j) for (int i = 0; i != M; ++i) sum += a[i][j]; return sum;}template &lt;int M, int N&gt;void testCase(){ cout &lt;&lt; \"testCase: \" &lt;&lt; M &lt;&lt; \",\" &lt;&lt; N &lt;&lt; endl; int data[M][N] = {1}; { auto start = chrono::steady_clock::now(); int sum = 0; for (int loop = 0; loop &lt; 10000; loop++) { sum += sumarrayrows&lt;M, N&gt;(data); } auto end = chrono::steady_clock::now(); cout &lt;&lt; \"\\tsum: \" &lt;&lt; sum &lt;&lt; \" time: \" &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count() &lt;&lt; endl; } { auto start = chrono::steady_clock::now(); int sum = 0; for (int loop = 0; loop &lt; 10000; loop++) { sum += sumarraycols&lt;M, N&gt;(data); } auto end = chrono::steady_clock::now(); cout &lt;&lt; \"\\tsum: \" &lt;&lt; sum &lt;&lt; \" time: \" &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count() &lt;&lt; endl; }}int main(){ testCase&lt;10, 10&gt;(); testCase&lt;100, 100&gt;();} 1clang ./cacheTest.cpp --std=c++14 -lstdc++ -O2 -o test.out 123456testCase: 10,10 sum: 10000 time: 5 sum: 10000 time: 306testCase: 100,100 sum: 10000 time: 15380 sum: 10000 time: 74331 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/21/Cache-friendly-code/"},{"title":"Vue+three.js","text":"朋友要做个h5 app项目，里面需要显示3D模型，问我这个做游戏的，用什么合适，是不是得用游戏引擎。 想了想觉得 Vue|React+three.js 配合起来应该合适。 做了个demo验证一下。 Demo的GitHub仓库传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/14/Vue-three-js/"},{"title":"crunch纹理压缩库的使用","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/22/crunch%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"一段应急的C++对象检查代码","text":"一个JNI项目，偶发离奇崩溃，怀疑是野指针类的问题。开address sanitizer本地难复现，测试版开as太卡，大部分测试机还是6、7的系统。 还好大部分都对象都派生自引用计数的基类，于是按fail-fast的思路憋出了以下代码，在加减引用和怀疑区域手动插桩检查。 附上代码，无关部分做了简化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;type_traits&gt;#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#define LOG(...) do { fprintf(stderr, __VA_ARGS__); fflush(stderr); } while (false)class Object{public: Object() : _falgs(0xcafecafe) { } virtual ~Object() { _falgs = 0xdeaddead; } // is not strict but help avoid most of error bool isValid() const { return static_cast&lt;const void *&gt;(this) &amp;&amp; (_falgs == 0xcafecafe); }private: int _falgs;};class ObjectCheck{public: template &lt;typename T&gt; static bool Check(T obj) { return doCheck&lt;T&gt;(obj); } template &lt;typename T&gt; static bool CheckNullable(T obj) { return obj == nullptr || doCheck&lt;T&gt;(obj); }private: template &lt;typename T&gt; static bool doCheck(typename std::enable_if&lt;std::is_base_of&lt;Object, typename std::remove_pointer&lt;T&gt;::type&gt;::value &amp;&amp; !std::is_void&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type obj) { LOG(\"dynamic_cast &amp;&amp; isValid %p %p \", dynamic_cast&lt;T&gt;(reinterpret_cast&lt;Object*&gt;(obj)), obj); return (obj == dynamic_cast&lt;T&gt;(reinterpret_cast&lt;Object*&gt;(obj)) &amp;&amp; obj-&gt;isValid()); } template &lt;typename T&gt; static bool doCheck(typename std::enable_if&lt;!std::is_base_of&lt;Object, typename std::remove_pointer&lt;T&gt;::type&gt;::value &amp;&amp; std::is_polymorphic&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type obj) { LOG(\"dynamic_cast %p %p \", dynamic_cast&lt;T&gt;(obj), obj); return (obj == dynamic_cast&lt;T&gt;(obj)); } template &lt;typename T&gt; static bool doCheck(typename std::enable_if&lt;std::is_void&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type obj) { LOG(\"static_cast void* \"); return (obj == static_cast&lt;void *&gt;(obj)); }};class Dummy{public: virtual ~Dummy() = default; int dummy;};class SubObject : public Object{public: int dummy;};int main(){ void *t1 = nullptr; Object *t2 = nullptr; Dummy *t3 = nullptr; SubObject *t4 = nullptr; Object *t5 = new Object(); Dummy *t6 = new Dummy(); SubObject *t7 = new SubObject(); SubObject *t8 = reinterpret_cast&lt;SubObject *&gt;(t6); SubObject *t9 = reinterpret_cast&lt;SubObject *&gt;(t5); SubObject *t10 = new SubObject(); delete t10; LOG(\"result %d \\n\", ObjectCheck::CheckNullable(t1)); LOG(\"result %d \\n\", ObjectCheck::CheckNullable(t2)); LOG(\"result %d \\n\", ObjectCheck::CheckNullable(t3)); LOG(\"result %d \\n\", ObjectCheck::CheckNullable(t4)); LOG(\"result %d \\n\", ObjectCheck::Check(t5)); LOG(\"result %d \\n\", ObjectCheck::Check(t6)); LOG(\"result %d \\n\", ObjectCheck::Check(t7)); LOG(\"result %d \\n\", ObjectCheck::Check(t8)); LOG(\"result %d \\n\", ObjectCheck::Check(t9)); LOG(\"result %d \\n\", ObjectCheck::Check(t10));} 输出 12345678910result 1 result 1 result 1 result 1 dynamic_cast &amp;&amp; isValid 0x7fca1cc02b40 0x7fca1cc02b40 result 1 dynamic_cast 0x7fca1cc02b50 0x7fca1cc02b50 result 1 dynamic_cast &amp;&amp; isValid 0x7fca1cc02b60 0x7fca1cc02b60 result 1 dynamic_cast &amp;&amp; isValid 0x0 0x7fca1cc02b50 result 0 dynamic_cast &amp;&amp; isValid 0x0 0x7fca1cc02b40 result 0 [1] 30935 segmentation fault ./a.out document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/15/%E4%B8%80%E6%AE%B5%E5%BA%94%E6%80%A5%E7%9A%84C-%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81/"},{"title":"node.js代码加密的一次尝试","text":"曾经有个合作项目用node.js开发的，大BOSS想软件给到对方时能不能不提供源码。 想到V8是有code cache的，如果把源码转成code cache不就满足需求了 因为是针对用户部署，版本兼容的问题可以先忽略 查了下node.js文档还真有相关接口暴露，经过一下午的折腾，搞出一个小工具 产生和使用code cache的接口很简单，折腾在require拦截，外加踩了个lazy compile的坑 不废话了，直接上代码 代码仓库传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/19/nodejs-%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/"},{"title":"对cocos2dx-lite的JSB做针对性优化","text":"前言 cocos2dx-lite（creator 2.0之前版本）同时支持多种js的vm，所以也就基本没有做针对特定vm的优化，项目优化时决定坚定的走V8路线，启动了针对V8的专门优化。当然这些优化都用宏定义分离开了，保障V8不可用时原有逻辑仍然不变。 具体优化条目 jsb绑定部分，避开se::State和se::Value直接生成V8形式的绑定，实测简单情况如 setPosition 函数效率提升50%左右。 更新V8到8.0以上，开启指针压缩，降低内存 20%左右，实际项目不同会有差别，别问我怎么编译的 所有源码使用v8::String::ExternalOneByteStringResource管理，减少内存copy（c++ -&gt; v8)，避免字符转码（ut8 -&gt; utf16)消耗，实际降低内存 40M ，当然这取决于脚本文件的多少，这个项目有大量脚本。为什么是OneByteString，因为js是utf16内码，但v8有个优化处理对于纯单字节的字符串是可以用OneByteString表示的可以省一半内存，当然源码需要预处理一下,使用unicode转意表示 1234567function to_latin1(str) { return str.replace(/[\\u007f-\\uffff]/g, function(ch) { var code = ch.charCodeAt(0).toString(16); while (code.length &lt; 4) code = \"0\" + code; return \"\\\\u\" + code; });} 使用v8::ArrayBuffer::Allocator使得部分ArrayBuffer可以使用宿主内存，避免宿主与VM间的copy 对纹理等大内存对象通过Isolate::AdjustAmountOfExternalAllocatedMemory告知V8外部内存占用情况 启用WeakRef启动参数增加--harmony-weak-refs,可以使用新标准中的WeakRef,解决动态加载的图片释放问题（项目有大量网络下载的图片）。目前会偶有崩溃，不确定是接入方式不对，还是什么原因，仍在观察中 其它 通用性和效率总是需要平衡的两个方面，针对具体项目是可以做一些更激进的选择 V8是个好项目，但文档还不够细，读代码可以了解细节 实在搞不清楚了可以参考node.js与V8结合的代码 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/16/%E5%AF%B9cocos2dx-lite%E7%9A%84JSB%E5%81%9A%E9%92%88%E5%AF%B9%E6%80%A7%E4%BC%98%E5%8C%96/"},{"title":"扩展cocos2dx版的fbx-conv","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/22/%E6%89%A9%E5%B1%95cocos2dx%E7%89%88%E7%9A%84fbx-conv/"},{"title":"技术版五彩斑斓的黑","text":"最近好几个post都只留了标题，迟迟补不上内容，有点要断更的尴尬😓。偶然看到个视频，觉得挺好的，发上来也算是续上了。 请欣赏视频 your browser does not support the video tag 观后感协商之下没有什么需求是满足不了的，如果有就换个表述😂 要永远充满信心才是合格的专家 附上一个五彩斑斓的黑 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/24/%E6%8A%80%E6%9C%AF%E7%89%88%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E9%BB%91/"},{"title":"记一次ReactNative优化","text":"这是一个试水项目，是找的代码做二次开发，在中低端手机上运行，滑动列表有点卡。 代码到手后总体浏览了一下，基本没有什么复杂计算，应该是对象创建和布局绘制占大头。 具体找到对应界面的样式和组件代码后，确实代码为了布局容易，层次嵌套比较多，样式书写简单直接，可以透明的容器都填充了颜色，经过一番调整，主要修改样式，部分扁平化层级后，问题解决。 这里不打算写具体修改的内容，原生平台的开发手册里都会有layout,overdraw和gpu profile相关的内容，里面有写的很好的指引说明。 (这里还改了react-navigation-stack里的StackViewCard，因为当时的版本，它的背景设置不了透明，本想略去的，因为本质还是改样式，但毕竟动到了三方组件里面，还是补充说明一下) 优化并不都是高深复杂的事情，很多时候认真做好基础的事情就已经能满足大部分需求。 看起来外在表现一样，可能对应的内在在代码不一样，优化在于用心。 overdraw对比 gpu对比 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/19/%E8%AE%B0%E4%B8%80%E6%AC%A1ReactNative%E4%BC%98%E5%8C%96/"},{"title":"通webview注入实现接管scatter签名请求","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/19/%E9%80%9Awebview%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E7%AE%A1scatter%E7%AD%BE%E5%90%8D%E8%AF%B7%E6%B1%82/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"netty","slug":"netty","link":"/tags/netty/"},{"name":"protostuff","slug":"protostuff","link":"/tags/protostuff/"},{"name":"Cache","slug":"Cache","link":"/tags/Cache/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"three.js","slug":"three-js","link":"/tags/three-js/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"Cocos2dX","slug":"Cocos2dX","link":"/tags/Cocos2dX/"},{"name":"V8","slug":"V8","link":"/tags/V8/"},{"name":"需求","slug":"需求","link":"/tags/%E9%9C%80%E6%B1%82/"},{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"EOS","slug":"EOS","link":"/tags/EOS/"},{"name":"区块链","slug":"区块链","link":"/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"webview","slug":"webview","link":"/tags/webview/"}],"categories":[{"name":"随记","slug":"随记","link":"/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"优化","slug":"优化","link":"/categories/%E4%BC%98%E5%8C%96/"},{"name":"回忆","slug":"回忆","link":"/categories/%E5%9B%9E%E5%BF%86/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"}]}